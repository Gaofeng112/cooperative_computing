#include "partition.h"
#include <algorithm>

std::vector<std::vector<std::string>> getEnabledStructures(const std::vector<std::string>& support_op, const std::vector<std::vector<std::string>>& structure) {
    std::vector<std::vector<std::string>> enable_structure;
    
    // 遍历所有的结构
    for (const auto& ops : structure) {
        bool enabled = true;
        // 检查结构中的所有算子是否都在support_op中
        for (const std::string& op : ops) {
            if (std::find(support_op.begin(), support_op.end(), op) == support_op.end()) {
                enabled = false;
                break;
            }
        }
        // 如果结构满足条件，则添加到enable_structure中
        if (enabled) {
            enable_structure.push_back(ops);
        }
    }
    
    return enable_structure;
}
std::vector<onnx::GraphProto> Subgraphs;

int checkAndPrintStructure(const onnx::GraphProto& graph, int startNodeIndex, const std::vector<std::vector<std::string>>& structure) {
    int find_flag = 0;
    int nextNodeIndex = startNodeIndex;
    for (const auto& seq : structure) {
        size_t structureIndex = 0; // 结构中的操作类型索引
        int currentNodeIndex = startNodeIndex;
        int structurestartNodeIndex = 0;
        // std::cout <<"seq:::::::" << seq[0] <<",structureIndex:" << structureIndex<< ",currentNodeIndex:" << currentNodeIndex << ",structurestartNodeIndex:" << structurestartNodeIndex <<std::endl;
        while (currentNodeIndex < graph.node_size()) {
            const auto& node = graph.node(currentNodeIndex);
            if (structureIndex >= seq.size()) {
                onnx::GraphProto subgraph;
                // 已经匹配到结构末尾，打印结构对应的节点名称,////并建立所需的子图，将其添加到Subgraphs队列中
                for (int i = structurestartNodeIndex; i < currentNodeIndex; ++i) {
                    *subgraph.add_node() = graph.node(i);
                    // std::cout << " " << graph.node(i).name() << std::endl;
                }
                Subgraphs.push_back(subgraph);
                find_flag = 1;
                nextNodeIndex = currentNodeIndex - 1;////从这个匹配的structure结束的位置继续进行匹配，指导遍历完所有node
                break;
            }
            // std::cout << "node.op_type():" << node.op_type() << std::endl;
            if (node.op_type() == seq[structureIndex]) {////如果node类型和结构中的操作类型匹配，继续查找
                // std::cout << "node.op_type():" << node.op_type() << std::endl;
                // 当前节点的操作类型与结构中的操作类型匹配，继续检查下一个节点
                structureIndex++;
                if (structureIndex == 1) {
                    structurestartNodeIndex = currentNodeIndex;
                }
            } else {
                // std::cout << "node.op_type():" << node.op_type() << std::endl;
                // 当前节点的操作类型与结构中的操作类型不匹配，重置结构中的操作类型索引
                break;
            }
            currentNodeIndex++;
        }
        if (find_flag) {
            break;//如果完成对structure的匹配或没有匹配到任何structure，都要跳出这个函数
        }
    }
    return nextNodeIndex;//返回结束的node序号
}
void findAndPrintStructures(const onnx::GraphProto &g, Device& d, PartitionStrategy strategy) {
    switch(strategy) {
        case SPILTE_CPU_STRUCTURE_FIRST:{
            // 获取启用的结构
            std::vector<std::vector<std::string>> enable_cpu_structure = getEnabledStructures(d.getCPUSupportOp(), d.getCPUStructure());

            for (int i = 0; i < g.node_size(); ++i) {
                // std::cout << "i:" << i << " " << g.node(i).name() << std::endl;
                i = checkAndPrintStructure(g, i, enable_cpu_structure);
            }
            break;
        }
        case SPILTE_NPU_STRUCTURE_FIRST:{
            // 获取启用的结构
            std::vector<std::vector<std::string>> enable_npu_structure = getEnabledStructures(d.getNPUSupportOp(), d.getNPUStructure());

            for (int i = 0; i < g.node_size(); ++i) {
                // std::cout << "i:" << i << " " << g.node(i).name() << std::endl;
                i = checkAndPrintStructure(g, i, enable_npu_structure);
            }
            break;
        }
        default:
            break;
    }
}
///////
//////////////7.22
std::vector<graph_adjacency_node> get_adjancency_list(const onnx::GraphProto &g, int* visited)
{
	std::vector<graph_adjacency_node> adjacency_list;
	int node_index=0;
	for(const auto& node : g.node())
	{
		visited[node_index]=0;
		graph_adjacency_node ad_node;
		const auto& outputs = node.output();
		for(const auto& output : outputs)
		{
			int output_node_index=0;
			for(const auto& output_node : g.node())//遍历图node的输入以匹配output
			{
				int find_flag=0;
				const auto& inputs = output_node.input();
				for(const auto& input : inputs)
				{
					if(output==input)
					{
						find_flag=1;
						break;
					}
				}
				if(find_flag==1)
				{
					if(std::find(ad_node.output_node_index.begin(),ad_node.output_node_index.end(),output_node_index)==ad_node.output_node_index.end())
					{
                        ad_node.output_node_index.push_back(output_node_index);
                        //break;不能break，因为一个输出可能连到多个节点上！
                    }
				}
				output_node_index++;
			}
		}
		node_index++;
		adjacency_list.push_back(ad_node);
	}
	return adjacency_list;
}
void DFS(const onnx::GraphProto &g,onnx::GraphProto &subgraph, 
		int* visited, const onnx::NodeProto& start_node,
		int node_index,std::vector<graph_adjacency_node>& adjacency_list,
		const std::vector<std::string>& support_op)
{
	*subgraph.add_node()=start_node;
    //std::cout<<"node pushed back!"<<start_node.name()<<std::endl;
	visited[node_index]=1;
	for(int i=0;i<adjacency_list[node_index].output_node_index.size();i++)
	{
		int next_node_index=adjacency_list[node_index].output_node_index[i];
		const auto & next_node=g.node(next_node_index);
        if(!visited[next_node_index]&&(std::find(support_op.begin(), support_op.end(), next_node.op_type()) != support_op.end()))        //尚未访问且op_type符合的邻接顶点
            DFS(g,subgraph,visited,next_node,next_node_index,adjacency_list,support_op);
	}
}
void determine_subgraphs(const onnx::GraphProto& g, Device& d, int* visited, 
												std::vector<graph_adjacency_node>& adjacency_list,PartitionStrategy strategy)
{
	//std::vector<onnx::GraphProto> subgraphs;
	std::vector<std::string> support_op;
	    switch(strategy) {
        case SPILTE_CPU_STRUCTURE_FIRST:{
			support_op=d.getCPUSupportOp();
            break;
        }
        case SPILTE_NPU_STRUCTURE_FIRST:{
			support_op=d.getNPUSupportOp();
            break;
        }
        default:
            break;
    }
	for(int i=0;i<g.node_size();i++)
	{
		if(!visited[i]&&(std::find(support_op.begin(), support_op.end(), g.node(i).op_type()) != support_op.end()))
		{
            //std::cout<<"op found!"<<std::endl;
			onnx::GraphProto subgraph;
			const auto& node=g.node(i);
			DFS(g,subgraph,visited,node,i,adjacency_list,support_op);
			Subgraphs.push_back(subgraph);
            std::cout<<"subgraph "<<Subgraphs.size()<<"generated! ";
            for(const auto& node :subgraph.node())
            {
                std::cout<<node.name()<<"--";
            }
            std::cout<<std::endl;
		}
	}
	//return 0;
}
////8.9 continue
void Tarjan(int index, int depth, std::vector<std::vector<int>>& strongly_connected_subgraphs,int* DFN, 
    int* LOW, std::vector<int>& stack_subgraphs, std::vector<std::vector<int>>& successors_Subgraphs)
{
    int rank = depth + 1;
    DFN[index] = LOW[index] = rank;//DFN和LOW初始化为0
    stack_subgraphs.push_back(index);
    for(const auto& successor : successors_Subgraphs[index])
    {
        if(DFN[successor] == 0)//未被访问过
        {
            Tarjan(successor, rank,strongly_connected_subgraphs, DFN, LOW, stack_subgraphs, successors_Subgraphs);//访问successor
            LOW[index] = std::min(LOW[index], LOW[successor]);
        }
        else if(std::find(stack_subgraphs.begin(),stack_subgraphs.end(),successor) != stack_subgraphs.end())
        {
            LOW[index] = std::min(LOW[index], DFN[successor]);
        }
    }
    if(LOW[index] == DFN[index])//是该强连通分量子树的最小根，将其后的所有node出栈,保存得到的强连通分量
    {
        auto it = stack_subgraphs.end() - 1; 
        std:: vector<int> strongly_connected; 
        while(*it != index)
        {
            strongly_connected.insert(strongly_connected.begin(), *it);
            stack_subgraphs.pop_back();
            it = stack_subgraphs.end() - 1;
        }
        strongly_connected.insert(strongly_connected.begin(), *it);
        strongly_connected_subgraphs.push_back(strongly_connected);
        stack_subgraphs.pop_back();//自身出栈
    }
}
void eliminate_connection(
    std::vector<std::vector<int>>& strongly_connected_subgraphs, 
    std::vector<onnx::GraphProto> Subgraphs,
    std::vector<onnx::GraphProto> otherSubgraphs)
{
    //遍历输入，找到没有来自内部节点的input的node，定为最先，遍历输出，同理
}

//////////////
///////
// Function to find other subgraphs in the original graph
std::vector<onnx::GraphProto> findOtherSubgraphs(const onnx::GraphProto& originalGraph, 
                                                 const std::vector<onnx::GraphProto>& knownSubgraphs) {
    std::vector<onnx::GraphProto> otherSubgraphs;

    // Create a set to store node names in the known subgraphs
    std::set<std::string> knownSubgraphNodeNames;
////获取已知子图和原图的node名称序列
    // Add node names from known subgraphs to the set
    for (const auto& subgraph : knownSubgraphs) {
        for (const auto& node : subgraph.node()) {
            knownSubgraphNodeNames.insert(node.name());
        }
    }

    // Create a set to store all node names in the original graph
    std::set<std::string> originalGraphNodeNames;
    for (const auto& node : originalGraph.node()) {
        originalGraphNodeNames.insert(node.name());
    }

    // Iterate over nodes in the original graph and find other subgraphs
    int startIndex = 0;
    int endIndex = -1;
    for (int i = 0; i < originalGraph.node_size(); ++i) {
        // If the current node name is not in the set of known subgraph node names, it belongs to a new subgraph////寻找不在已知子图中的node，将其记为endIndex
        if (knownSubgraphNodeNames.find(originalGraph.node(i).name()) == knownSubgraphNodeNames.end()) {
            // Determine the end index of the current subgraph
            endIndex = i;
        } else {
            // Create a new subgraph and add nodes from startIndex to endIndex////如果找到了已知子图中的node，并且它的前面存在未知子图中的node，那就对之前的node做总结，创立未知子图
            if (endIndex >= startIndex) {
                onnx::GraphProto newSubgraph;
                for (int j = startIndex; j <= endIndex; ++j) {
                    *newSubgraph.add_node() = originalGraph.node(j);
                }
                otherSubgraphs.push_back(newSubgraph);
            }

            // Update the startIndex for the next subgraph
            startIndex = i + 1;
        }
    }

    // Create the last subgraph (if any) from startIndex to the end of the original graph
    if (startIndex < originalGraph.node_size()) {
        onnx::GraphProto lastSubgraph;
        for (int j = startIndex; j < originalGraph.node_size(); ++j) {
            *lastSubgraph.add_node() = originalGraph.node(j);
        }
        otherSubgraphs.push_back(lastSubgraph);
    }

    return otherSubgraphs;
}

std::vector<onnx::GraphProto> processNpuSubgraphs(std::vector<onnx::GraphProto>& Subgraphs_, const std::vector<std::string>& NPUSupportOp, std::vector<std::string> NPUPreferOp) {
    // 创建一个新的向量来存储包含 NPUSupportOp 的子图
    std::vector<onnx::GraphProto> NPUSubgraphs;
    std::vector<onnx::GraphProto> CPUSubgraphs;

    // 遍历每个子图
    for (size_t i = 0; i < Subgraphs_.size(); ++i) {
        auto subgraph = Subgraphs_[i];

        // 遍历当前子图中的每个节点
        int npustartIndex = 0;
        int npuendIndex = -1;
        int cpustartIndex = 0;
        int cpuendIndex = -1;

        for (int j = 0; j < subgraph.node_size(); ++j) {
            const onnx::NodeProto& node = subgraph.node(j);

            // 检查当前节点的操作是否在 NPUSupportOp 中
            if (std::find(NPUSupportOp.begin(), NPUSupportOp.end(), node.op_type()) != NPUSupportOp.end()) {
                if (cpuendIndex >= cpustartIndex) {
                    onnx::GraphProto newSubgraph;
                    for (int k = cpustartIndex; k <= cpuendIndex; ++k) {
                        *newSubgraph.add_node() = subgraph.node(k);
                    }
                    CPUSubgraphs.push_back(newSubgraph);
                }
                npuendIndex = j;
                cpustartIndex = j + 1;
            } else {
                if (npuendIndex >= npustartIndex) {
                    // 判断这一部分在NPU上执行是否有意义
                    int flag = 0;
                    onnx::GraphProto newSubgraph;
                    for (int k = npustartIndex; k <= npuendIndex; ++k) {
                        // 在 vector 中查找目标字符串
                        auto it = std::find(NPUPreferOp.begin(), NPUPreferOp.end(), subgraph.node(k).op_type());
                        if (it != NPUPreferOp.end()) {
                            flag = 1;
                        }
                        *newSubgraph.add_node() = subgraph.node(k);
                    }

                    // 1.这个NPU子图中存在可以大幅度并行加速的算子（包含NPU only算子），合法
                    // 2.这个NPU子图没有可以大幅加速的算子，但是如果足够大,量变引起质变，合法
                    //      .2分许这个字图输入输出需要传输的数据量，如果数据量大，则可以往前或者往后挪一两个
                    
                    // 1.这个NPU子图中存在可以大幅度并行加速的算子
                    if (flag) {
                        // 查询子图的输入输出是否可以微调，主要是为了减少传输
                        if (npustartIndex != 0) {
                            // 记录当前输入节点的input size

                        }
                        if (npustartIndex < subgraph.node_size() - 1) {
                            /* code */
                        }

                        NPUSubgraphs.push_back(newSubgraph);
                    } else if (npuendIndex - npustartIndex + 1 > 10) { //TODO这里有待商榷
                        NPUSubgraphs.push_back(newSubgraph);
                    } else {
                        CPUSubgraphs.push_back(newSubgraph);
                    }
                }
                cpuendIndex = j;
                npustartIndex = j + 1;
            }
        }

        if (npustartIndex < subgraph.node_size() && npuendIndex >= npustartIndex) {
            int flag = 0;
            onnx::GraphProto lastSubgraph;
            for (int j = npustartIndex; j < subgraph.node_size(); ++j) {
                // 在 vector 中查找目标字符串
                auto it = std::find(NPUPreferOp.begin(), NPUPreferOp.end(), subgraph.node(j).op_type());
                if (it != NPUPreferOp.end()) {
                    flag = 1;
                }
                *lastSubgraph.add_node() = subgraph.node(j);
            }
            if (flag) {
                NPUSubgraphs.push_back(lastSubgraph);
            } else if (npuendIndex - npustartIndex + 1 > 10) { //TODO这里有待商榷
                NPUSubgraphs.push_back(lastSubgraph);
            } else {
                CPUSubgraphs.push_back(lastSubgraph);
            }
        } else if (cpustartIndex < subgraph.node_size() && cpuendIndex >= cpustartIndex) {
            onnx::GraphProto lastSubgraph;
            for (int j = cpustartIndex; j < subgraph.node_size(); ++j) {
                *lastSubgraph.add_node() = subgraph.node(j);
            }
            CPUSubgraphs.push_back(lastSubgraph);
        }
        
    }

    Subgraphs_ = NPUSubgraphs;
    return CPUSubgraphs;
}

std::vector<onnx::GraphProto> processCpuSubgraphs(std::vector<onnx::GraphProto>& Subgraphs_, const std::vector<std::string>& CPUSupportOp) {
    // 创建一个新的向量来存储包含 NPUSupportOp 的子图
    std::vector<onnx::GraphProto> NPUSubgraphs;
    std::vector<onnx::GraphProto> CPUSubgraphs;

    // 遍历每个子图
    for (size_t i = 0; i < Subgraphs_.size(); ++i) {
        auto subgraph = Subgraphs_[i];

        // 遍历当前子图中的每个节点
        int npustartIndex = 0;
        int npuendIndex = -1;
        int cpustartIndex = 0;
        int cpuendIndex = -1;

        for (int j = 0; j < subgraph.node_size(); ++j) {
            const onnx::NodeProto& node = subgraph.node(j);

            // 检查当前节点的操作是否在 CPUSupportOp 中
            if (std::find(CPUSupportOp.begin(), CPUSupportOp.end(), node.op_type()) == CPUSupportOp.end()) {
                if (cpuendIndex >= cpustartIndex) {
                    onnx::GraphProto newSubgraph;
                    for (int k = cpustartIndex; k <= cpuendIndex; ++k) {
                        *newSubgraph.add_node() = subgraph.node(k);
                    }
                    CPUSubgraphs.push_back(newSubgraph);
                }
                npuendIndex = j;
                cpustartIndex = j + 1;
            } else {
                if (npuendIndex >= npustartIndex) {
                    onnx::GraphProto newSubgraph;
                    for (int k = npustartIndex; k <= npuendIndex; ++k) {
                        *newSubgraph.add_node() = subgraph.node(k);
                    }
                    NPUSubgraphs.push_back(newSubgraph);
                }
                cpuendIndex = j;
                npustartIndex = j + 1;
            }
        }

        if (npustartIndex < subgraph.node_size() && npuendIndex >= npustartIndex) {
            onnx::GraphProto lastSubgraph;
            for (int j = npustartIndex; j < subgraph.node_size(); ++j) {
                *lastSubgraph.add_node() = subgraph.node(j);
            }
            NPUSubgraphs.push_back(lastSubgraph);
        } else if (cpustartIndex < subgraph.node_size() && cpuendIndex >= cpustartIndex) {
            onnx::GraphProto lastSubgraph;
            for (int j = cpustartIndex; j < subgraph.node_size(); ++j) {
                *lastSubgraph.add_node() = subgraph.node(j);
            }
            CPUSubgraphs.push_back(lastSubgraph);
        }
        
    }

    Subgraphs_ = CPUSubgraphs;
    return CPUSubgraphs;
}

std::vector<onnx::GraphProto> CheckWhetherNpuSupports(std::vector<onnx::GraphProto>& Subgraphs_, Device& d) {
    return processNpuSubgraphs(Subgraphs_, d.getNPUSupportOp(), d.getNPUPreferOp());
}

std::vector<onnx::GraphProto> CheckWhetherCpuSupports(std::vector<onnx::GraphProto>& Subgraphs_, Device& d) {
    return processCpuSubgraphs(Subgraphs_, d.getCPUSupportOp());
}

void Partition::PartitionGraph(const onnx::GraphProto &g, Device& d, PartitionStrategy strategy, const std::unordered_map<std::string, NodeIOSize> &node_io_size) {
    std::unordered_set<NodeTensor> initializerNames = getInitializer(g);
    std::unordered_set<NodeTensor> IOvalueNames = getIOvalue(g);
    int* visited = (int*)malloc(g.node_size()*sizeof(int));
    std::vector<graph_adjacency_node> adjacency_list=get_adjancency_list(g, visited);
    // int temp_index=0;
    // for(auto& node : adjacency_list)
    // {
    //     std::cout<<"adjacency "<<temp_index<<" name:"<<g.node(temp_index).name()<<" ";
    //     for(int i=0;i<node.output_node_index.size();i++)
    //     {
    //         std::cout<<node.output_node_index[i]<<" ";
    //     }
    //     std::cout<<std::endl;
    //     temp_index++;
    // }
    //determine_subgraphs(g, d, visited, adjacency_list,strategy);
    findAndPrintStructures(g, d, strategy);////匹配主要平台(cpu/NPU)的结构并创立子图
    // //////////////////7.19
    // std::vector<std::unordered_set<std::string>> subgraphs_1_input_nodes_;
    // std::vector<std::unordered_set<std::string>> subgraphs_1_nodes_;
    // for (const auto& sg : Subgraphs) {
    //     std::unordered_set<NodeTensor> graphInputs;
    //     determineGraphInput(sg, IOvalueNames, graphInputs);////确定Subgraph中的每个子图的输入量

    //     // 根据输入
    //     std::unordered_set<std::string> graphInputsNodes;
    //     for (const auto& input : graphInputs) {
    //         auto nodename = findInputNode(g, input.name);////找到每个子图输入对应的网络节点输出
    //         if (nodename != "") {
    //             graphInputsNodes.insert(nodename);////所有subgraph的输入节点
    //         }
    //     }
    //     subgraphs_1_input_nodes_.push_back(graphInputsNodes);
    //     subgraphs_1_nodes_.push_back(collectNodeNames(sg));////所有subgraph的所有节点
    // }

    // for (size_t i = 0; i < Subgraphs.size(); ++i) {
    //     if (subgraphs_1_input_nodes_[i].empty()) {
    //         int mergeIndex = canMerge(i, subgraphs_1_input_nodes_, subgraphs_1_nodes_[i]);////第mergeIndex个子图的输入节点全在subgraphs_1_nodes_[i]里，可以被合并进这个子图
    //         if (mergeIndex != -1) {
    //             std::cout << "Merge possible for graphs " << i << " and " << mergeIndex << std::endl;
    //             // Merge the graphs
    //             if (i < mergeIndex) {
    //                 mergeGraphs(Subgraphs[i], Subgraphs[mergeIndex]);
    //                 Subgraphs.erase(Subgraphs.begin() + mergeIndex);
    //             } else {
    //                 mergeGraphs(Subgraphs[mergeIndex], Subgraphs[i]);
    //                 Subgraphs.erase(Subgraphs.begin() + i);
    //             }

    //             if (mergeIndex < i) {
    //                 i--;
    //             }
    //         }
    //     }
    // }
    // ////////////////////end
    int node_sum = 0;
    // 遍历结构并打印每个元素
    std::ofstream outFile("./subgraphs_1.txt");
    if (!outFile.is_open()) {
        std::cerr << "Error opening file." << std::endl;
        exit(0);
    }
    int id = 0;
    for (const auto& vec : Subgraphs) {
        outFile << " subgraph" << id << ":";
        for (const auto& node : vec.node()) {
            outFile << node.name() << " ";
        }
        id++;
        outFile << std::endl;
        node_sum += vec.node_size();
    }

    auto otherSubgraphs = findOtherSubgraphs(g, Subgraphs);
    std::ofstream outFile_2("./subgraphs_2.txt");
    if (!outFile_2.is_open()) {
        std::cerr << "Error opening file." << std::endl;
        exit(0);
    }
    std::cout << "before:" << std::endl;
    for (const auto& vec : otherSubgraphs) {
        outFile_2 << " subgraph" << id << ":";
        for (const auto& node : vec.node()) {
            outFile_2 << node.name() << " ";
        }
        id++;
        outFile_2 << std::endl;
        node_sum += vec.node_size();
    }////把未知子图对应的node存入文件

    // 由于大型网络顺序遍历其node，往往并不是按照bfs的拓扑来的，因此切出来的图可能有些是可以合并的，因此这里要检查一下
    // 获得所有同类型子图的输入tensor的节点名称，同时统计每个子图的node名称，若某个子图的所有输入节点都来自某一个子图，认为这俩可以合并

//两子图合并，若后一个子图有来自于其他设备的子图，则 index+1,合并后的子图，不能大于1！

    std::vector<std::unordered_set<std::string>> subgraphs_2_input_nodes_;
    std::vector<std::unordered_set<std::string>> subgraphs_2_nodes_;
    for (const auto& sg : otherSubgraphs) {
        std::unordered_set<NodeTensor> graphInputs;
        determineGraphInput(sg, IOvalueNames, graphInputs);////确定otherSubgraph中的每个子图的输入量

        // 根据输入
        std::unordered_set<std::string> graphInputsNodes;
        for (const auto& input : graphInputs) {
            auto nodename = findInputNode(g, input.name);////找到每个子图输入对应的网络节点输出
            if (nodename != "") {
                graphInputsNodes.insert(nodename);////所有othersubgraph的输入节点
            }
        }
        subgraphs_2_input_nodes_.push_back(graphInputsNodes);
        subgraphs_2_nodes_.push_back(collectNodeNames(sg));////所有othersubgraph的所有节点
    }

    for (size_t i = 0; i < otherSubgraphs.size(); ++i) {
        if (subgraphs_2_input_nodes_[i].empty()) {
            int mergeIndex = canMerge(i, subgraphs_2_input_nodes_, subgraphs_2_nodes_[i]);////第mergeIndex个子图的输入节点全在subgraphs_2_nodes_[i]里，可以被合并进这个子图
            if (mergeIndex != -1) {
                std::cout << "Merge possible for graphs " << i << " and " << mergeIndex << std::endl;
                // Merge the graphs
                if (i < mergeIndex) {
                    mergeGraphs(otherSubgraphs[i], otherSubgraphs[mergeIndex]);
                    otherSubgraphs.erase(otherSubgraphs.begin() + mergeIndex);
                } else {
                    mergeGraphs(otherSubgraphs[mergeIndex], otherSubgraphs[i]);
                    otherSubgraphs.erase(otherSubgraphs.begin() + i);
                }

                if (mergeIndex < i) {
                    i--;
                }
            }
        }
    }

    std::ofstream outFile_3("./subgraphs_3.txt");
    if (!outFile_3.is_open()) {
        std::cerr << "Error opening file." << std::endl;
        exit(0);
    }
////merge后的othersubgraph
    for (const auto& vec : otherSubgraphs) {
        outFile_3 << " subgraph" << id << ":";
        for (const auto& node : vec.node()) {
            outFile_3 << node.name() << " ";
        }
        id++;
        outFile_3 << std::endl;
    }

    std::cout << "graph node size:" << g.node_size() << std::endl;
    std::cout << "sub node size:" << node_sum << std::endl;


    std::vector<std::unordered_set<NodeTensor>> subgraphs_1_inputs;
    std::vector<std::unordered_set<std::string>> subgraphs_1_input_nodes;
    std::vector<std::unordered_set<std::string>> subgraphs_1_nodes;
    for (const auto& sg : Subgraphs) {
        std::unordered_set<NodeTensor> graphInputs;
        determineGraphInput(sg, IOvalueNames, graphInputs);
        // if (graphInputs.empty() == true)
        // std::cout << "graphInputs are empty" << std::endl;
        subgraphs_1_inputs.push_back(graphInputs);

        // 根据输入
        std::unordered_set<std::string> graphInputsNodes;
        for (const auto& input : graphInputs) {
            auto nodename = findInputNode(g, input.name);
            if (nodename != "") {
                graphInputsNodes.insert(nodename);
            }
        }
        subgraphs_1_input_nodes.push_back(graphInputsNodes);
        subgraphs_1_nodes.push_back(collectNodeNames(sg));
    }

    std::vector<std::unordered_set<NodeTensor>> subgraphs_2_inputs;
    std::vector<std::unordered_set<std::string>> subgraphs_2_input_nodes;
    std::vector<std::unordered_set<std::string>> subgraphs_2_nodes;
    for (const auto& sg : otherSubgraphs) {
        std::unordered_set<NodeTensor> graphInputs;
        determineGraphInput(sg, IOvalueNames, graphInputs);
        subgraphs_2_inputs.push_back(graphInputs);

        // 根据输入
        std::unordered_set<std::string> graphInputsNodes;
        for (const auto& input : graphInputs) {
            auto nodename = findInputNode(g, input.name);
            if (nodename != "") {
                graphInputsNodes.insert(nodename);
            }
        }
        subgraphs_2_input_nodes.push_back(graphInputsNodes);
        subgraphs_2_nodes.push_back(collectNodeNames(sg));
    }
    ////merge后的othersubgraph的输入node和所有node
    //得出了全部的input后再确定output
    std::vector<std::unordered_set<NodeTensor>> subgraphs_1_outputs;

    int node_number=0;

    for (const auto& sg : Subgraphs) {
        std::unordered_set<NodeTensor> graphOutputs;
        node_number+=sg.node_size();
        determineGraphOutput(g,sg, subgraphs_1_inputs, subgraphs_2_inputs, graphOutputs);
        subgraphs_1_outputs.push_back(graphOutputs);
    }
    std::vector<std::unordered_set<NodeTensor>> subgraphs_2_outputs;
    for (const auto& sg : otherSubgraphs) {
        std::unordered_set<NodeTensor> graphOutputs;
        node_number+=sg.node_size();
        determineGraphOutput(g,sg, subgraphs_1_inputs, subgraphs_2_inputs, graphOutputs);
        subgraphs_2_outputs.push_back(graphOutputs);
    }
    
    std::cout<<"total number of nodes in subgraphs:"<<node_number<<std::endl;
    std::cout<<"total number of nodes in origional graph:"<<g.node_size()<<std::endl;

/////////////////////////6.29
    //std::unordered_set<NodeTensor> graphs_outputs=getOutvalue(g);

    std::vector<std::unordered_set<NodeTensor>> graphs_inputs;
    graphs_inputs.insert(graphs_inputs.end(),subgraphs_1_inputs.begin(),subgraphs_1_inputs.end());
    //std::cout <<  " size1:"<<graphs_inputs.size()<<std::endl;
    graphs_inputs.insert(graphs_inputs.end(),subgraphs_2_inputs.begin(),subgraphs_2_inputs.end());
    //std::cout <<  " size2:"<<graphs_inputs.size()<<std::endl;
    std::vector<std::unordered_set<NodeTensor>> graphs_outputs;
    graphs_outputs.insert(graphs_outputs.end(),subgraphs_1_outputs.begin(),subgraphs_1_outputs.end());
    graphs_outputs.insert(graphs_outputs.end(),subgraphs_2_outputs.begin(),subgraphs_2_outputs.end());
    std::vector<int> order_Subgraphs(graphs_inputs.size());
    std::vector<int> issort_Subgraphs(graphs_inputs.size());
    std::vector<std::vector<int>> predecessors_Subgraphs(graphs_inputs.size());
    std::vector<std::vector<int>> successors_Subgraphs(graphs_inputs.size());
    int sub1_size=subgraphs_1_inputs.size();
    int sub2_size=subgraphs_2_inputs.size();
    ////
    int finished_flag=0;int sort_count=0;
    while(!finished_flag) 
    {
        finished_flag=1;
        if(sort_count==0)
        {
            for(int i=0; i<graphs_inputs.size();i++) ////遍历所有子图
            {
                int find_flag=0;
                for(const auto& g_input : graphs_inputs[i])////遍历某个子图的所有input
                {
                    for(int j=0; j< graphs_outputs.size();j++)////检查该子图的某个input是否是output
                    {
                        //std::cout<<graphs_outputs[j]
                        if(graphs_outputs[j].find(g_input)!=graphs_outputs[j].end())
                        {
                        find_flag=1;
                        //std::cout<<"match!"<<std::endl;
                        break;
                        }
                    }
                    if(find_flag){break;}
                }
                if(!find_flag)
                {
                    order_Subgraphs[i]=0;
                    issort_Subgraphs[i]=1;
                }
                else {order_Subgraphs[i]=1;issort_Subgraphs[i]=0;finished_flag=0;}
            }
        }
        else
        {
            for(int i=0; i<graphs_inputs.size();i++) ////遍历所有子图
            {
                int find_flag=0;
                std::vector<int> predecessors;
                //bool is_successor_of_former_subgraphs_in_this_cycle=0; 
                if(issort_Subgraphs[i]==1){continue;}////如果已经排过序了，跳过这个子图
                for(const auto& g_input : graphs_inputs[i])////遍历某个子图的所有input
                {
                    
                    for(int j=0; j< graphs_outputs.size();j++)////检查该子图的某个input是否是第j个子图的output
                    {
                        if((graphs_outputs[j].find(g_input)!=graphs_outputs[j].end()))////该子图的某个input是第j个子图的output
                        {
                            if((issort_Subgraphs[j]==0))//若第j个子图尚未被排序
                            {
                                find_flag=1;
                                //auto iter = graphs_outputs[j].find(g_input);
                                //std::cout<<iter.name()<<std::endl;
                                break;
                            }
                            //else{std::cout<<"subgraph"<<i<<"has been sorted"<<std::endl;}
                            predecessors.push_back(j);//加入前驱
                        }
                         //else{std::cout<<"an input is not found!!!"<<std::endl;}
                    }
                    if(find_flag){break;}
                }
                if(!find_flag)
                {
                    
                    order_Subgraphs[i]=sort_count;
                    //issort_Subgraphs[i]=1;
                    predecessors_Subgraphs[i].insert(predecessors_Subgraphs[i].end(),predecessors.begin(),predecessors.end());
                }
                else {order_Subgraphs[i]=sort_count+1;issort_Subgraphs[i]=0;finished_flag=0;}
                if(i==graphs_inputs.size()-1)//本循环到最后再统一加入队列，防止出现本轮循环新加入的为后面子图的前驱
                  {
                    for(int j=0; j<graphs_inputs.size();j++)
                    {
                        if(order_Subgraphs[j]==sort_count)
                        {
                            issort_Subgraphs[j]=1;
                            //std::cout<<"subgraph"<<"has been sorted"<<std::endl;
                        }
                    }
                }
            }
        }
        
        sort_count++;
        //std::cout<<sort_count<<std::endl;
    }
    //find successors
    for(int i=0;i<graphs_inputs.size();i++)
    {
        for(int j=0;j<graphs_inputs.size();j++)
        {
            if(find(predecessors_Subgraphs[j].begin(),predecessors_Subgraphs[j].end(),i)!=predecessors_Subgraphs[j].end())
            {
                successors_Subgraphs[i].push_back(j);
            }
        }
    }
    char* sub1_type,*sub2_type;
    if(strategy==SPILTE_CPU_STRUCTURE_FIRST)
    {
        sub1_type="CPU";
        sub2_type="NPU";
    }
    else{
        sub1_type="NPU";
        sub2_type="CPU";
    }
    std::cout <<  " order"<<std::endl;
    for(auto element : order_Subgraphs)
    {
        std::cout << element << " ";
    }
    std::cout<<std::endl;

    std::string file_name = "subgraphs_ios.txt";
    std::ofstream outfile1(file_name);
    if (!outfile1.is_open()) {
        std::cerr << "Error opening file." << std::endl;
        exit(0);
    }

    for(int i=0;i<graphs_inputs.size();i++)
    {
        outfile1 << (i>=sub1_size?sub2_type:sub1_type)<<"subgraph"<<(i>=sub1_size?(i-sub1_size):i)<<": order"<<order_Subgraphs[i];
        outfile1<<"--input-name ";
        std::cout << (i>=sub1_size?sub2_type:sub1_type)<<"subgraph"<<(i>=sub1_size?(i-sub1_size):i)<<": order"<<order_Subgraphs[i]<<std::endl;
        std::cout << "Inputs:";
        for(auto element :  graphs_inputs[i])
        {
            std::cout<<element.name<<"; size:";
            for(auto Size : element.shape)
            {std::cout<<Size<<" ";}
            outfile1<<element.name<<";";
        }
        std::cout << std::endl;
        std::cout << "Outputs:";
        outfile1<<"--output-name ";
        for(auto element :  graphs_outputs[i])
        {
            std::cout<<element.name<<"; size:";
            for(auto Size : element.shape)
            {std::cout<<Size<<" ";}
            outfile1<<element.name<<";";
        }
        outfile1<<std::endl;
        std::cout << std::endl;
        std::cout <<  " The predecessors of "<<  (i>=sub1_size?sub2_type:sub1_type)<<"subgraph"<<(i>=sub1_size?(i-sub1_size):i)<<": ";
        for(auto element : predecessors_Subgraphs[i])
        {
            std::cout <<  (element>=sub1_size?sub2_type:sub1_type)<<"subgraph"<<(element>=sub1_size?(element-sub1_size):element) <<"; ";
        }
            std::cout <<std::endl;
        std::cout <<  " The successors of "<<  (i>=sub1_size?sub2_type:sub1_type)<<"subgraph"<<(i>=sub1_size?(i-sub1_size):i)<<": ";
        for(auto element : successors_Subgraphs[i])
        {
             std::cout <<  (element>=sub1_size?sub2_type:sub1_type)<<"subgraph"<<(element>=sub1_size?(element-sub1_size):element) <<"; ";
        }
            std::cout <<std::endl;
    }
    outfile1.close();
    //std::cout<<Subgraphs[0].node(0).name()<<std::endl;
///////////////////////

    // 生成粗颗粒度的cut指令
    // Print the elements of the set
    for (const auto& tensor : IOvalueNames) {
        std::cout << "Name: " << tensor.name << ", Shape: [";
        for (size_t i = 0; i < tensor.shape.size(); ++i) {
            std::cout << tensor.shape[i];
            if (i < tensor.shape.size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << "]" << std::endl;
    }

    switch (d.getType()) {
        case DeviceType::Licheepi:{
            if (strategy == SPILTE_CPU_STRUCTURE_FIRST) {
                d.GenerateCutInstruction(Subgraphs, "cpu", subgraphs_1_inputs, subgraphs_1_outputs);
                d.GenerateCutInstruction(otherSubgraphs, "npu", subgraphs_2_inputs, subgraphs_2_outputs);
            } else if (strategy == SPILTE_NPU_STRUCTURE_FIRST) {
                d.GenerateCutInstruction(Subgraphs, "npu", subgraphs_1_inputs, subgraphs_1_outputs);
                d.GenerateCutInstruction(otherSubgraphs, "cpu", subgraphs_2_inputs, subgraphs_2_outputs);
            }
            break;
        }
        default:
            std::cout << "Unknown device type" << std::endl;
            exit(0);
    }

    // 接下来应该是细致调节
    ////////////////
    free(visited);
    ///////////////////
}
